var m=`:host\r
{\r
    display: flex; /* needed for reverse ordering */\r
    flex-direction: column;\r
    overflow: auto;\r
}\r
\r
::slotted([data-entry])\r
{\r
    cursor: pointer;\r
    flex-shrink: 0; /* prevents squishing due to the flex display */\r
}\r
\r
::slotted([data-active][data-entry])\r
{\r
    text-decoration: underline;\r
}\r
\r
::slotted([data-entry][data-reversed])\r
{\r
    scale: .98;\r
    opacity: .5;\r
}`;var h=(r=>(r.Create="create",r.Read="read",r.Update="update",r.Delete="delete",r.Custom="custom",r))(h||{});var b="data-reversed",f="data-active",g="data-entry",p="data-timestamp",A=new CSSStyleSheet;A.replaceSync(m);var v="action-history",d=class extends HTMLElement{onBack=async(e,t,i,n,r)=>{};onForward=async(e,t,i,n,r)=>{};get entryAttributeName(){return this.getAttribute("entry-attribute")??g}get activeAttributeName(){return this.getAttribute("active-attribute")??f}get reversedAttributeName(){return this.getAttribute("reversed-attribute")??b}get timestampAttributeName(){return this.getAttribute("timestamp-attribute")??p}#t;constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<slot></slot>",this.shadowRoot.adoptedStyleSheets.push(A),this.#t=this.shadowRoot.querySelector("slot"),this.#t.addEventListener("slotchange",e=>{let t=this.#t.assignedElements();this.querySelector(`[${this.activeAttributeName}][${this.timestampAttributeName}]`)?.removeAttribute(this.activeAttributeName);let i=null;for(let n=0;n<t.length;n++){if(t[n].getAttribute(this.entryAttributeName)==null||(i=t[n],t[n].hasAttribute(this.timestampAttributeName)))continue;let r=[...this.querySelectorAll("[data-reversed]")];for(let a=0;a<r.length;a++)r[a].remove();t[n].setAttribute(this.timestampAttributeName,Date.now().toString()),this.updateOrder(),this.dispatchEvent(new CustomEvent("add",{detail:{target:t[n]}}))}this.querySelector(`[${this.activeAttributeName}]`)==null&&i!=null&&i.getAttribute(this.reversedAttributeName)==null&&i.toggleAttribute(this.activeAttributeName,!0)}),this.addEventListener("click",e=>{let t=e.target.closest(`[${this.entryAttributeName}]`);t!=null&&this.activateEntry(t)})}updateOrder(e){if(e=e??this.#t.assignedElements(),this.hasAttribute("reverse"))for(let t=0;t<e.length;t++){let i=this.children.length-t;e[t].tabIndex=i,e[t].style.order=i.toString()}else for(let t=0;t<e.length;t++)e[t].removeAttribute("tabindex"),e[t].style.removeProperty("order")}back(){let e=[...this.children],t=e.find(r=>r.getAttribute(this.activeAttributeName)!=null);if(t==null)return;let i=e.indexOf(t),n=i-1;if(n==-1){new Promise(async r=>{await this.onBack(t,t,[t],n,i),t.toggleAttribute(this.reversedAttributeName,!0),t.removeAttribute(this.activeAttributeName),r()});return}n>=0&&n<e.length&&e[n].click()}forward(){let e=[...this.children],t=e.find(n=>n.getAttribute(this.activeAttributeName)!=null),i=t==null?e.length>0?0:-1:e.indexOf(t)+1;i!=-1&&i<e.length&&e[i].click()}async activateEntry(e){if(e.hasAttribute(this.activeAttributeName)){this.dispatchEvent(new CustomEvent("refresh",{detail:{target:e}}));return}let t=await this.#e(e);this.dispatchEvent(new CustomEvent("activate",{detail:t}))}async#e(e){let t=[...this.children],i=t.find(l=>l.getAttribute(this.activeAttributeName)!=null);i?.removeAttribute(this.activeAttributeName);let n=t.indexOf(e),r=i==null?-1:t.indexOf(i),a=[],o=[];if(r>n)for(let l=r;l>n;l--)a.push(t[l]);else if(r<n)for(let l=r+1;l<=n;l++)o.push(t[l]);else throw new Error("Unable to determine action");let c={target:e,previousActiveEntry:i,toReverse:a,toActivate:o,targetIndex:n,previousActiveEntryIndex:r};if(a.length>0){for(let s=0;s<a.length;s++)a[s].toggleAttribute(this.reversedAttributeName,!0);let l=a[a.length-1];await this.onBack(l,i,a,t.indexOf(l),r)}else if(o.length>0){for(let s=0;s<o.length;s++)o[s].removeAttribute(this.reversedAttributeName);let l=o[o.length-1];await this.onForward(l,i,o,t.indexOf(l),r)}return e.toggleAttribute(this.activeAttributeName,!0),c}async reverseEntry(e){if(e.hasAttribute(this.reversedAttributeName))return;let t=[...this.children],i=t.find(s=>s.getAttribute(this.activeAttributeName)!=null);i?.removeAttribute(this.activeAttributeName);let n=t.indexOf(e),r=i==null?-1:t.indexOf(i),a=[e],o=[];if(n==r){await this.onBack(e,e,[e],n,r),e.toggleAttribute(this.reversedAttributeName,!0),e.removeAttribute(this.activeAttributeName);let s=this.querySelector(`[data-entry]:has(+ [data-timestamp="${e.dataset.timestamp}"])`);s?.toggleAttribute(this.activeAttributeName,!0),this.dispatchEvent(new CustomEvent("reverse",{detail:{target:e,previousActiveEntry:i,toReverse:a,toActivate:o,targetIndex:n,previousActiveEntryIndex:r}}));return}if(r>n)for(let s=r;s>n;s--)a.push(t[s]);else if(r<n)for(let s=r+1;s<=n;s++)o.push(t[s]);else throw new Error("Unable to determine action");let c={target:e,previousActiveEntry:i,toReverse:a,toActivate:o,targetIndex:n,previousActiveEntryIndex:r};if(a.length>0){for(let u=0;u<a.length;u++)a[u].toggleAttribute(this.reversedAttributeName,!0);let s=a[a.length-1];await this.onBack(s,i,a,t.indexOf(s),r)}else if(o.length>0){for(let u=0;u<o.length;u++)o[u].removeAttribute(this.reversedAttributeName);let s=o[o.length-1];await this.onForward(s,i,o,t.indexOf(s),r)}let l=this.querySelector(`[data-entry]:has(+ [data-timestamp="${e.dataset.timestamp}"])`);l?.toggleAttribute(this.activeAttributeName,!0),e.removeAttribute(this.activeAttributeName),this.dispatchEvent(new CustomEvent("reverse",{detail:c}))}static observedAttributes=["reverse"];attributeChangedCallback(e,t,i){e=="reverse"&&this.updateOrder()}};customElements.get(v)==null&&customElements.define(v,d);export{f as ATTRIBUTENAME_ACTIVE,g as ATTRIBUTENAME_ENTRY,b as ATTRIBUTENAME_REVERSED,p as ATTRIBUTENAME_TIMESTAMP,d as ActionHistoryElement,h as HistoryEntryType};
